{"ast":null,"code":"import { clientsClaim } from 'workbox-core';\nimport { ExpirationPlugin } from 'workbox-expiration';\nimport { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';\nimport { registerRoute } from 'workbox-routing';\nimport { StaleWhileRevalidate } from 'workbox-strategies';\nclientsClaim();\nprecacheAndRoute(self.__WB_MANIFEST);\nconst fileExtensionRegexp = new RegExp('/[^/?]+\\\\.[^/]+$');\nregisterRoute(\n// Return false to exempt requests from being fulfilled by index.html.\n_ref => {\n  let {\n    request,\n    url\n  } = _ref;\n  // If this isn't a navigation, skip.\n  if (request.mode !== 'navigate') {\n    return false;\n  } // If this is a URL that starts with /_, skip.\n\n  if (url.pathname.startsWith('/_')) {\n    return false;\n  } // If this looks like a URL for a resource, because it contains // a file extension, skip.\n\n  if (url.pathname.match(fileExtensionRegexp)) {\n    return false;\n  } // Return true to signal that we want to use the handler.\n\n  return true;\n}, createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html'));\nregisterRoute(\n// Add in any other file extensions or routing criteria as needed.\n_ref2 => {\n  let {\n    url\n  } = _ref2;\n  return url.origin === self.location.origin && url.pathname.endsWith('.png');\n}, new StaleWhileRevalidate({\n  cacheName: 'images',\n  plugins: [\n  // Ensure that once this runtime cache reaches a maximum size the\n  // least-recently used images are removed.\n  new ExpirationPlugin({\n    maxEntries: 50\n  })]\n}));\nself.addEventListener('message', event => {\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});","map":{"version":3,"names":["clientsClaim","ExpirationPlugin","precacheAndRoute","createHandlerBoundToURL","registerRoute","StaleWhileRevalidate","self","__WB_MANIFEST","fileExtensionRegexp","RegExp","_ref","request","url","mode","pathname","startsWith","match","process","env","PUBLIC_URL","_ref2","origin","location","endsWith","cacheName","plugins","maxEntries","addEventListener","event","data","type","skipWaiting"],"sources":["/Users/hishamraffiaiidrissi/React_Portfolio/src/service-worker.js"],"sourcesContent":["\n\nimport { clientsClaim } from 'workbox-core';\nimport { ExpirationPlugin } from 'workbox-expiration';\nimport { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';\nimport { registerRoute } from 'workbox-routing';\nimport { StaleWhileRevalidate } from 'workbox-strategies';\n\nclientsClaim();\n\n\nprecacheAndRoute(self.__WB_MANIFEST);\n\n\nconst fileExtensionRegexp = new RegExp('/[^/?]+\\\\.[^/]+$');\nregisterRoute(\n  // Return false to exempt requests from being fulfilled by index.html.\n  ({ request, url }) => {\n    // If this isn't a navigation, skip.\n    if (request.mode !== 'navigate') {\n      return false;\n    } // If this is a URL that starts with /_, skip.\n\n    if (url.pathname.startsWith('/_')) {\n      return false;\n    } // If this looks like a URL for a resource, because it contains // a file extension, skip.\n\n    if (url.pathname.match(fileExtensionRegexp)) {\n      return false;\n    } // Return true to signal that we want to use the handler.\n\n    return true;\n  },\n  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')\n);\n\nregisterRoute(\n  // Add in any other file extensions or routing criteria as needed.\n  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'), \n  new StaleWhileRevalidate({\n    cacheName: 'images',\n    plugins: [\n      // Ensure that once this runtime cache reaches a maximum size the\n      // least-recently used images are removed.\n      new ExpirationPlugin({ maxEntries: 50 }),\n    ],\n  })\n);\n\n\nself.addEventListener('message', (event) => {\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n\n\n"],"mappings":"AAEA,SAASA,YAAY,QAAQ,cAAc;AAC3C,SAASC,gBAAgB,QAAQ,oBAAoB;AACrD,SAASC,gBAAgB,EAAEC,uBAAuB,QAAQ,oBAAoB;AAC9E,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,oBAAoB,QAAQ,oBAAoB;AAEzDL,YAAY,CAAC,CAAC;AAGdE,gBAAgB,CAACI,IAAI,CAACC,aAAa,CAAC;AAGpC,MAAMC,mBAAmB,GAAG,IAAIC,MAAM,CAAC,kBAAkB,CAAC;AAC1DL,aAAa;AACX;AACAM,IAAA,IAAsB;EAAA,IAArB;IAAEC,OAAO;IAAEC;EAAI,CAAC,GAAAF,IAAA;EACf;EACA,IAAIC,OAAO,CAACE,IAAI,KAAK,UAAU,EAAE;IAC/B,OAAO,KAAK;EACd,CAAC,CAAC;;EAEF,IAAID,GAAG,CAACE,QAAQ,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;IACjC,OAAO,KAAK;EACd,CAAC,CAAC;;EAEF,IAAIH,GAAG,CAACE,QAAQ,CAACE,KAAK,CAACR,mBAAmB,CAAC,EAAE;IAC3C,OAAO,KAAK;EACd,CAAC,CAAC;;EAEF,OAAO,IAAI;AACb,CAAC,EACDL,uBAAuB,CAACc,OAAO,CAACC,GAAG,CAACC,UAAU,GAAG,aAAa,CAChE,CAAC;AAEDf,aAAa;AACX;AACAgB,KAAA;EAAA,IAAC;IAAER;EAAI,CAAC,GAAAQ,KAAA;EAAA,OAAKR,GAAG,CAACS,MAAM,KAAKf,IAAI,CAACgB,QAAQ,CAACD,MAAM,IAAIT,GAAG,CAACE,QAAQ,CAACS,QAAQ,CAAC,MAAM,CAAC;AAAA,GACjF,IAAIlB,oBAAoB,CAAC;EACvBmB,SAAS,EAAE,QAAQ;EACnBC,OAAO,EAAE;EACP;EACA;EACA,IAAIxB,gBAAgB,CAAC;IAAEyB,UAAU,EAAE;EAAG,CAAC,CAAC;AAE5C,CAAC,CACH,CAAC;AAGDpB,IAAI,CAACqB,gBAAgB,CAAC,SAAS,EAAGC,KAAK,IAAK;EAC1C,IAAIA,KAAK,CAACC,IAAI,IAAID,KAAK,CAACC,IAAI,CAACC,IAAI,KAAK,cAAc,EAAE;IACpDxB,IAAI,CAACyB,WAAW,CAAC,CAAC;EACpB;AACF,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}